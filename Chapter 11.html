<html>
<link href="https://fonts.googleapis.com/css?family=Signika" rel="stylesheet">
<link rel="stylesheet" href="style.css">
<title> A Level Computing </title>
<body>

<div class="title">
	<h1> A Level Computing Theory </h1><br/>
</div>
<a href="index.html">Home</a>

<div class="container clearfix">
	<div class="general" id="navbar" style="width:20%;">
		<input type="text" id="myInput" onkeyup="myFunction()" placeholder="Search for Chapters..">
		<ul id="myUL">
			<li><a href="ALevelChapter1.html" class="header">Chapter 1</a></li>
			<li><a href="Chapter 2.html" class="header">Chapter 2</a></li>
			<li><a href="Chapter 3.html" class="header">Chapter 3</a></li>
			<li><a href="Chapter 4.html" class="header">Chapter 4</a></li>
			<li><a href="Chapter 5.html" class="header">Chapter 5</a></li>
			<li><a href="Chapter 6.html" class="header">Chapter 6</a></li>
			<li><a href="Chapter 7.html" class="header">Chapter 7</a></li>
			<li><a href="Chapter 8.html" class="header">Chapter 8</a></li>
			<li><a href="Chapter 9.html" class="header">Chapter 9</a></li>
			<li><a href="Chapter 10.html" class="header">Chapter 10</a></li>
			<li><a href="Chapter 11.html" class="header">Chapter 11</a></li>
			<li><a href="#ToD">Types of Data</a></li>
			<li><a href="#RD">Representing Data</a></li>
			<li><a href="#SN">Storing Numbers</a></li>
			<li><a href="#IS">Images and Sound</a></li>
			<li><a href="#RI">Representing Instructions</a></li>
			<li><a href="#EQ">Example Questions</a></li>
			<li><a href="Chapter 12.html" class="header">Chapter 12</a></li>
			<li><a href="Chapter 13.html" class="header">Chapter 13</a></li>
		</ul>
	</div>
	<div class="general" style="width:75%;">
		<h2>Data Types</h2>
		<h3 id="ToD">Types of data</h3>
			<p> Data can take multiple different forms on a computer, this is because different types of data need to behave differently for example you couldn't add two words together as they aren't numbers and so they are stored differently to numbers.<br />
				Eg: "Four" is a string(text), "-4" is an integer(whole number), "4.7" is a float(decimal number), "True" is boolean(true/false - 1/0).<br /><br /></p>
		<h3 id="RD">Representing data</h3>
			<p> Computers store everything in binary and thus every regular symbol you could want to display is stored in a big table on your computer. This table was originally made by a group of american computer developers. The original table had 128 characters and each had their own 7 bit binary number.<br /><br />
				This was then extended to 8 bits so that 256 characters could be stored. This table was called the ASCII(American Standard Character Information Interchange) table. The reason this table was developed is so that all computers no matter who built them if they had this same table with each character stored as the same number then an "a" on 1 computer would also be an "a" on another computer. This is useful because it allows communication between computers and without it a sentence on one computer would be an unreadable mess on another computer.<br /><br />
				Next came along UNICODE, at first 16 bits for each number meaning 65535 characters. This was then extended to have no upper limit of characters using a system called pages. UNICODE contains many languages from around the world even including emoji's invented in Japan by a man named Shigetaka Kurita in 1998.<br /><br />
				Below is a sample from the ASCII 8 bit table showing 0-9 and the upper/lower case alphabets:<br /></p>
				<img src="Images/ascii-table.jpg" style="width:50%; margin:15px;">	
		<h3 id="SN">Storing Numbers</h3>
			<p> Positive integers are fairly easy to store, any number up to 255 can be stored using 8 bits of binary. This is very different to the way we use numbers normally, we use the denary system normally eg: 1,10,100 etc. However in a computer binary is used. To store a number in binary you can use 1 of two methods.<br /><br />
				The first method:<br />
				Divide the number by two repeatedly using the remainders as the binary. eg:163<br />
				163 / 2 = 81 with 1 remainder<br />81 / 2 = 40 with 1 remainder<br />40 / 2 = 20 with 0 remainder<br />20 / 2 = 10 with 0 remainder<br />10 / 2 = 5 with 0 remainder<br />5 / 2 = 2 with 1 remainder<br />2 / 2 = 1 with 0  remainder<br />1 / 2 = 0 with 1 remainder<br /> 
				This would leave the binary number to be: 11000101<br /><br />
				The second method:<br />
				Using the table below input the binary number then add up all the values with a 1 underneath<br />
				<img src="Images/Binary Table.jpg" style="width:50%; margin:15px;"><br />	
				Negative integers are slightly different to positive ones, you can use the 2nd method from above but you have to edit the table ever to slightly. There are two different changes you can make to the headings.<br /><br />
				The first is called the Sign and Magnitude method as the first column tells you whether the number is positive or negative.<br />
				<img src="Images/SignAndMagnitude Table.jpg" style="width:50%; margin:15px;"><br />
				The second is called two's complement, it is a more effective method than sign and magnitude as it requires less processing to convert between denary and binary as they are all the same data type.<br />
				<img src="Images/TwosComplement Table.jpg" style="width:50%; margin:15px;"><br /><br />
				Now after Binary we will cover Hexidecimal, this is a base 16 number system so you can have 0-9 then A-F for numbers 10-15. To convert between denary and hex we use the same system as we did for binary and divide the number by the base(16) using the remainders as values for our hex number or you can use the this table:<br />
				<img src="Images/HextoDenary Table.jpg" style="width:50%; margin:15px;"><br />
				The reason hexidecimal exists is to make binary numbers much easier to read by humans, as long strings of 1's and 0's can become very hard to distinguish between. To convert between hexidecimal and binary you simply break the binary number up into nibbles (4bits) and use the table below converting each nibble to a single hex digit.<br />
				<img src="Images/HextoBinary Table.jpg" style="width:50%; margin:15px;"><br /></p>
		<h3 id="IS">Images and Sound</h3>
			<p> There are two main ways of storing images, by using vectors or by using a bitmap. In bit map we have a big grid with each square being a pixel and in each square a binary number representing the colour of that pixel. The size of this number changes how many different colour options we can have, if we have 16bits per pixel we can use 2^16 (65536) different colours.<br /><br />
				The second method is to plot simple vector shapes/graphs with equations that fill in the different sections of the image, this method can be much more efficient as less information has to be stored however it cannot be compressed as losing any information would ruin the image whereas a bitmap image can be compressed by reducing the resolution(number of pixels per unit area) or colour depth(number of bits used to store each pixel).<br /><br />
				A long with the image itself something called metadata(data about data) is stored, this information contains things such as the resolution, the dimensions of the image, also on phone cameras information such as location of image taken can also be stored using gps.<br /><br />
				Next up is sound, sound used to be stored using analog vinyl records but for a long time now we've been using digital recordings of sound. This digital recording is a trade off as even though there is no static and less faults in the recording the way we record the sound waves means that the digital version isn't true to the analog wave and has lower sound quality.<br /><br />
				The way we record sound is by taking samples of the wave at regular intervals and then recreating the sound as best we can by playing all the different sample levels one after another, as a drawing it looks like this:<br />
				<img src="Images/Sound wave.jpg" style="width:50%; margin:15px;"><br />
				As you can see from the image above there are gaps between the samples and the wave, the more samples we take the smaller these gaps are. The rate at which we take these samples is called the sample rate, a high sample rate improves the quality of the sound. The number of bits we use to record the 'tone' at each sample is called the bit rate, similarly to images if we have 16bits per sample we can use 2^16 different tones. Typical bitrates for sound are between 100-300 thousand bits per second.</p>
		<h3 id="RI">Representing Instructions</h3>
			<p> An instruction is made of two parts, the operator and the operand both are stored together as one binary number/pattern. The operator tells the computer what process is being performed, eg: add a number to the accumulator. The operand can either be the number being used in a calculation or it can be the memory of the address of the number to be used. The computer has no way of distiguishing between instructions and data so programs must have proper allocation of data/instructions so that whne the computer looks in a memory location and assumes it is a certain type of information (data/instruction) it doesnt cause an error or do the wrong calculation.
				</p>
		<h3 id="EQ">Example Questions</h3>
			<p> Convert from Denary to Binary:<br />
				49 = 00110001<br />
				131 = 10000011<br />
				127 = 01111111<br />
				255 = 11111111<br />
				203 = 11001011<br />
				Convert Binary to Denary:<br />
				10111001 = 185<br />
				00010001 = 17<br />
				11011111 = 223<br />
				00000000 = 0<br /><br />
				Convert from Hexidecimal to Denary:<br />
				12  = 18<br />
				FF  = 255<br />
				3D  = 61<br />
				2BE = 702<br />
				AB5 =  2741<br />
				Convert from Hexidecimal to Binary<br />
				92   = 146
				5C   = 92
				FB   = 251
				ABCD = 43981
				FFFF =65535
				</p>
	</div>
</div>

</body>
</html>

<script>
function myFunction() {
    // Declare variables
    var input, filter, ul, li, a, i;
    input = document.getElementById('myInput');
    filter = input.value.toUpperCase();
    ul = document.getElementById("myUL");
    li = ul.getElementsByTagName('li');

    // Loop through all list items, and hide those who don't match the search query
    for (i = 0; i < li.length; i++) {
        a = li[i].getElementsByTagName("a")[0];
        if (a.innerHTML.toUpperCase().indexOf(filter) > -1) {
            li[i].style.display = "";
        } else {
            li[i].style.display = "none";
        }
    }
}
</script>